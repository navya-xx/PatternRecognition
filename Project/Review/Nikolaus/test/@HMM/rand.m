function [X,S]=rand(h,nSamples)%[X,S]=rand(h,nSamples);generates a random sequence of data%from a given Hidden Markov Model.%%Input:%h=         HMM object%nSamples=  maximum no of output samples (scalars or column vectors)%%Result:%X= matrix or row vector with output data samples%S= row vector with corresponding integer state values%   obtained from the h.StateGen component.%   nS= length(S) == size(X,2)= number of output samples.%   If the StateGen can generate infinite-duration sequences,%       nS == nSamples%   If the StateGen is a finite-duration MarkovChain,%       nS <= nSamples%%----------------------------------------------------%Code Authors:%----------------------------------------------------if numel(h)>1    error('Method works only for a single object');end;%S=zeros(1,nSamples);%X=zeros(1,nSamples);%space for resulting row vector of Observationsmc = h.StateGen;outputDistr = h.OutputDistr;%sample state from initial matrix%S(1,1) = rand(mc, 1);%sample first observation%mc_observations = outputDistr(S(1,1))%X(1,1) = rand(outputDistr(S(1,1)), 1);%Generate state sequenceS = rand(mc, nSamples);%space for resulting row vector of States%X=zeros(1,length(S));%%%%% ************** vectorX=zeros(h.OutputDistr(1, 1).DataSize, length(S));%Generate observation sequence for index = 1: length(S)    X(:, index) = rand(outputDistr(S(1,index)), 1);end% % % for index = 2: nSamples% % %     % % %     %fix initial matrix based on previous choosen state% % %     %initial = zeros(1, length(mc.InitialProb));% % %     % % %     %initial(1,S(1,index-1)) = 1.0;%fix that the previous state will happen% % %     %mc.InitialProb = initial;% % %     mc.InitialProb = mc.TransitionProb(S(1,index-1),:);% % %     %sample a state% % %     S(1,index) = rand(mc, 1);% % %     % % %     %sample an observation from the given state% % %     X(1, index) = rand(outputDistr(S(1,index)), 1);% % % % % % end%continue coding from here, and delete the error message.%error('Not yet implemented fr');end