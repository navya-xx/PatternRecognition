function [X,S]=rand(h,nSamples)%[X,S]=rand(h,nSamples);generates a random sequence of data%from a given Hidden Markov Model.%%Input:%h=         HMM object%nSamples=  maximum no of output samples (scalars or column vectors)%%Result:%X= matrix or row vector with output data samples%S= row vector with corresponding integer state values%   obtained from the h.StateGen component.%   nS= length(S) == size(X,2)= number of output samples.%   If the StateGen can generate infinite-duration sequences,%       nS == nSamples%   If the StateGen is a finite-duration MarkovChain,%       nS <= nSamples%%----------------------------------------------------%Code Authors:%----------------------------------------------------if numel(h)>1    error('Method works only for a single object');end;T = 0;abort = 0;          % exit conditionexit_state = -1;    % to be assigned as...isfinite = 0;       % finite markov chain conditionif(h.StateGen.nStates < size(h.StateGen.TransitionProb,2) ) % A is not square => there is an extra final state    isfinite = 1;    exit_state = size(h.StateGen.TransitionProb,2);    fprintf('Finite-duration Markov Chain detected.\n');    mc = MarkovChain;    mc.InitialProb = [h.StateGen.InitialProb; 0];    mc.TransitionProb = [h.StateGen.TransitionProb; zeros(1,h.StateGen.nStates), 1];    S = rand(mc,nSamples);else    S = rand(h.StateGen, nSamples);endstateLen = size(S,2); %if the chain generates finite seq, size(S) <= nsamplessampleFeature = rand(h.OutputDistr(S(1)),1); %a sample output to get the size fromfeatureLen = size(sampleFeature,1); % 1 if float, n if vectorX = zeros([featureLen,stateLen]);%disp('debug')%disp(size(sampleFeature))%disp(size(X))if featureLen > 1    for i=1:stateLen        if( isfinite && S(i) == exit_state && ~abort )                abort = 1;                T = i - 1;                fprintf('Exit state reached at T = %d.\n',i);        else            if(~abort)                X(:,i) = rand(h.OutputDistr(S(i)),1);            end        end    endelse    for i=1:stateLen        if( isfinite && S(i) == exit_state && ~abort )                abort = 1;                T = i - 1;                fprintf('Exit state reached at T = %d.\n',i);        else            if( ~abort )                X(i) = rand(h.OutputDistr(S(i)),1);            end        end    endendif(~T)    T = stateLen;endif( isfinite )      % discard all future states if exit state was reached.    S = S(1:T);    X = X(:,1:T);endend